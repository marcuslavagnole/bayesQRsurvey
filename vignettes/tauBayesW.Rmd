---
title: "tauBayesW: Bayesian Weighted Quantile Regression"
author: "Tomas Rodriguez Taborda"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tauBayesW}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  warning = FALSE,
  message = FALSE
)
```

<p align="center">
  <img src="logo_tau.png" width="180" alt="tauBayesW logo"/>
</p>

# tauBayesW: An R Framework for Bayesian Weighted Quantile Regression

[![CRAN_Status_Badge](https://www.r-pkg.org/badges/version/tauBayesW)](https://cran.r-project.org/package=tauBayesW)
[![downloads](https://cranlogs.r-pkg.org/badges/tauBayesW)](https://cran.r-project.org/package=tauBayesW)

## What is tauBayesW?

**tauBayesW** is an R package that provides a comprehensive framework for Bayesian weighted quantile regression with survey designs. The package implements MCMC and EM algorithms to handle complex survey data while maintaining computational efficiency using a C++ backend. Some of its key features include:

- **Handles survey weights naturally** under a Bayesian framework
- **Implements multiple MCMC methods** (ALD, Score, Approximate)  
- **Estimates multiple quantiles efficiently** using EM algorithms
- **Provides comprehensive visualization** tools
- **Includes model diagnostics** and convergence checking

## Installation

```{r}
if (!requireNamespace("MASS", quietly = TRUE)) install.packages("MASS")
```


```{r installation, eval=FALSE}
# From CRAN (when available)
#install.packages("tauBayesW")

# From GitHub (development version)
remotes::install_github("torodriguezt/tauBayesW")
```

```{r setup}
library(tauBayesW)
set.seed(123)
```

## Citation

To cite tauBayesW in publications, please use:

```{r citation, eval=FALSE}
citation("tauBayesW")
```

## Getting Started

tauBayesW provides two main functions to fit a bayesian quantile regression model with survey weights using MCMC and EM algorithms, also each of them has a plotting function to visualize the results and a summary method to extract key information:

- **`bqr.svy()`**: ðŸŽ¯ Bayesian quantile regression for multiple quantiles with survey weights using MCMC algorithms
- **`mo.bqr.svy()`**: ðŸ“Š Bayesian multivariate and multidirectional quantile regression for multiple quantiles with survey weights using Expected Maximization algorithm
- **`plot_quantile()`**: ðŸŽ¨ Comprehensive visualization functions for quantile regression

### Basic Usage

Let's start with a simple example using survey data for the MCMC algorithms:

```{r basic-example}
# Simulate survey data with design weights
n <- 500
x1 <- rnorm(n)
x2 <- rbinom(n, 1, 0.4)
y <- 1 + 2*x1 + 1.5*x2 + rnorm(n)
weights <- runif(n, 0.5, 2)  # Survey weights

data <- data.frame(y, x1, x2)

# Single quantile regression (median)
model_median <- bqr.svy(y ~ x1 + x2, 
                        data = data,
                        weights = weights,
                        quantile = 0.5,
                        niter = 2000,
                        burnin = 500,
                        verbose = FALSE)

```


```{r}
print(model_median)
```

```{r}
summary(model_median)
```

And using the EM algorithm

```{r}
model_median <- mo.bqr.svy(y ~ x1 + x2, 
                        data = data,
                        weights = weights,
                        quantile = 0.5,
                        max_iter = 2000,
                        epsilon = 1e-8,
                        verbose = FALSE)
```


```{r}
print(model_median)
```
```{r}
summary(model_median)
```


### Multiple quantiles

tauBayesW implements three different MCMC approaches, all of them allow to fit more than one quantile with only one call:

```{r mcmc-methods}
n <- 800
x1 <- runif(n)
x2 <- rnorm(n)
y <- 3 + 2*x1 + 1.5*x2 + rnorm(n)
weights <- rep(1, n)
data <- data.frame(y, x1, x2)

methods <- c("ald", "score", "approximate")
results <- list()

model_ald <- bqr.svy(y ~ x1 + x2,
                               data = data,
                               weights = weights,
                               quantile = c(0.5, 0.95),
                               method = "ald",
                               n_mcmc = 60000,
                               burnin = 25000,
                               verbose = FALSE)

summary(model_ald)

model_score <- bqr.svy(y ~ x1 + x2,
                               data = data,
                               weights = weights,
                               quantile = c(0.5, 0.95),
                               method = "score",
                               n_mcmc = 60000,
                               burnin = 25000,
                               verbose = FALSE)

summary(model_score)


model_approximate <- bqr.svy(y ~ x1 + x2,
                               data = data,
                               weights = weights,
                               quantile = c(0.5, 0.95),
                               method = "approximate",
                               n_mcmc = 60000,
                               burnin = 25000,
                               verbose = FALSE)

summary(model_approximate)

```



For the Expected-Maximization Algorithm

```{r multiple-quantiles}
# Multiple quantiles simultaneously
quantiles <- c(0.1, 0.25, 0.5, 0.75, 0.9)

model_em<- mo.bqr.svy(y ~ x1 + x2,
                               data = data,
                               weights = weights,
                               quantile = c(0.5, 0.95),
                               max_iter = 1500,
                               epsilon = 1e-6,
                               verbose = FALSE)

summary(model_em)
```

### Visualization

```{r}
n_vis <- 300
x_vis <- seq(-2, 2, length.out = n_vis)
y_vis <- 1 + 2*x_vis + (0.5 + 0.3*abs(x_vis))*rnorm(n_vis) 
weights_vis <- rgamma(n_vis, 2, 1)
data_vis <- data.frame(y = y_vis, x = x_vis)
```


```{r visualization, fig.width=8, fig.height=6}

# Fit single quantile for plotting
model_vis <- bqr.svy(y ~ x, 
                     data = data_vis,
                     weights = weights_vis,
                     quantile = 0.5,
                     niter = 2000,
                     burnin = 500,
                     verbose = FALSE)

# Plot quantile regression with data points
plot_quantile_with_points.bqr.svy(model_vis, data = data_vis, predictor = "x",
                          point_alpha = 0.6,
                          main = "Bayesian Quantile Regression (Ï„ = 0.5)")
```


```{r}
fit1d <- mo.bqr.svy(y ~ x, 
                     data = data_vis,
                     weights = weights_vis,
                     quantile = 0.5,
                     max_iter  = 2000,
                     epsilon   = 1e-8,
                     verbose = FALSE)


drawQuantile1D(
  fit        = fit1d,
  datafile   = data_vis,
  response   = "Y",
  x_var      = "x",
  x_grid     = seq(-2, 2, length.out = 200),
  xValue     = NULL,         
  paintedArea = TRUE,
  band_choice = "symmetric", 
  show_data   = TRUE
)

```



### Prior information

We can also use informative prior distributions

For the MCMC case

```{r}
# ---------------------
# Example data
# ---------------------
set.seed(123)
n  <- 400
x1 <- rnorm(n)
x2 <- rnorm(n)
w  <- runif(n, 0.5, 2)   # weights
tau <- 0.5               # target quantile

y <- 1 + 2 * x1 - 1.5 * x2 + rnorm(n)

data_ex <- data.frame(y, x1, x2, w)

# ---------------------
# Informative prior
# ---------------------
prior_info <- prior_default(
  p     = 3,
  b0    = c(0, 1.5, -1.0),          # prior means
  B0    = diag(c(0.5, 0.25, 0.25)), # small variances => more concentrated prior
  c0    = 2,                        # hyperparameter for ALD (more informative than 0.001)
  C0    = 1,
  names = c("(Intercept)", "x1", "x2")
)

# ---------------------
# Fit with the 3 methods
# ---------------------

# ALD method
fit_ald <- bqr.svy(
  formula  = y ~ x1 + x2,
  weights  = w,
  data     = data_ex,
  quantile = tau,
  method   = "ald",
  prior    = prior_info,
  niter    = 2000,
  burnin   = 500,
  thin     = 5
)

# Score method
fit_score <- bqr.svy(
  formula  = y ~ x1 + x2,
  weights  = w,
  data     = data_ex,
  quantile = tau,
  method   = "score",
  prior    = prior_info,
  niter    = 2000,
  burnin   = 500,
  thin     = 5
)

# Approximate method
fit_ap <- bqr.svy(
  formula  = y ~ x1 + x2,
  weights  = w,
  data     = data_ex,
  quantile = tau,
  method   = "approximate",
  prior    = prior_info,
  niter    = 10000,
  burnin   = 2500,
  thin     = 5
)

# ---------------------
# Results
# ---------------------
cat("\n--- ALD ---\n")
print(fit_ald$beta)

cat("\n--- Score ---\n")
print(fit_score$beta)

cat("\n--- Approximate ---\n")
print(fit_ap$beta)

```

For the EM algorithm


```{r}
# ---------------------
# Example data
# ---------------------
set.seed(456)
n <- 150
p <- 2  # number of predictors (excluding intercept)

# Simulated predictors
x1 <- rnorm(n)
x2 <- rnorm(n)
w  <- runif(n, 0.5, 2)   # survey weights

# True model: intercept + slopes
y <- 1 + 1.8 * x1 - 1.2 * x2 + rnorm(n, 0, 1)

data_ex <- data.frame(y, x1, x2, w)

# ---------------------
# Informative prior for mo.bqr.svy
# ---------------------
prior_info <- mo_prior_default(
  p           = 3,                             # intercept + 2 slopes
  beta_mean   = c(0.5, 1.5, -1.0),              # prior means
  beta_cov    = diag(c(0.2, 0.15, 0.15)),       # small variances -> concentrated prior
  sigma_shape = 2,                              # more informative than 0.001
  sigma_rate  = 1,
  names       = c("(Intercept)", "x1", "x2")
)

# ---------------------
# Fit model with EM algorithm
# ---------------------
fit_mo <- mo.bqr.svy(
  formula   = y ~ x1 + x2,
  weights   = w,
  data      = data_ex,
  quantile  = c(0.25, 0.5, 0.75),  # multiple quantiles
  algorithm = "em",
  prior     = prior_info,
  max_iter  = 1000,
  epsilon   = 1e-6,
  verbose   = FALSE
)

# ---------------------
# Results
# ---------------------
summary(fit_mo)

```

### Multivariate EM Algorithm

We present examples for the bivariate and trivariate cases to illustrate the plotting functions, while emphasizing that the EM algorithm is applicable to response variables of arbitrary dimension.

#### Bivariate Case

```{r}
n <- 600
x <- rnorm(n)
w <- runif(n, 0.5, 1.5)

eps1 <- rnorm(n, sd = 0.6)
eps2 <- rnorm(n, sd = 0.5)
mu1  <-  0.8*x
mu2  <- -0.5*x
Y1 <- mu1 + eps1 * (0.5 + 0.3*abs(x))
Y2 <- mu2 + eps2 * (0.4 + 0.2*abs(x))

df <- data.frame(Y1 = Y1, Y2 = Y2, x = x, w = w)
```


```{r}
fit <- mo.bqr.svy(
  formula   = cbind(Y1, Y2) ~ x,
  data      = df,
  weights   = df$w,
  quantile  = c(0.5, 0.8),
  n_dir     = 14,
  max_iter  = 2000,
  epsilon   = 1e-8,
  verbose   = FALSE
)
```


```{r}
summary(fit)
```
```{r}
xgrid <- data.frame(x = c(-1, 1))
drawQuantileRegion(
  fit, datafile=df, response=c("Y1","Y2"),
  xValue = xgrid,
  paintedArea = FALSE,           
  comparison  = TRUE,            
  show_data   = TRUE
)
```

#### Trivariate Case

```{r}
# --- 1) Datos simulados (3 respuestas)
set.seed(123)
n <- 400
x <- rnorm(n)
w <- runif(n, 0.5, 1.5)

mu1 <-  0.7 * x
mu2 <- -0.5 * x
mu3 <-  0.3 * x

Y1 <- mu1 + (0.5 + 0.3*abs(x)) * rnorm(n, sd = 0.6)
Y2 <- mu2 + (0.4 + 0.2*abs(x)) * rnorm(n, sd = 0.5)
Y3 <- mu3 + (0.3 + 0.2*abs(x)) * rnorm(n, sd = 0.7)

df <- data.frame(Y1=Y1, Y2=Y2, Y3=Y3, x=x, w=w)
```

```{r}
fit3 <- mo.bqr.svy(
  formula   = cbind(Y1, Y2, Y3) ~ x,
  data      = df,
  weights   = df$w,
  quantile  = c(0.5, 0.8),
  n_dir     = 75,
  max_iter  = 2000,
  epsilon   = 1e-8,
  verbose   = FALSE
)
```


```{r}
drawQuantileRegion_3D(
  fit3,
  xValue = data.frame(x = c(-1, 0, 1)),
  opacity = 0.4,
  datafile = df, response = c("Y1","Y2","Y3"),
  show_points = TRUE, point_opacity = 0.2, point_size = 2,
  nrows = 1, ncols = NULL, show_titles = TRUE
)
```


## Methodology

### Theoretical Background

The package implements Bayesian quantile regression using the **Asymmetric Laplace Distribution (ALD)** representation:

$$y_i \sim ALD(\mu_i, \sigma, \tau)$$

where $\mu_i = \mathbf{x}_i^T \boldsymbol{\beta}$ and the likelihood is:

$$f(y_i|\mu_i,\sigma,\tau) = \frac{\tau(1-\tau)}{\sigma} \exp\left(-\rho_\tau\left(\frac{y_i-\mu_i}{\sigma}\right)\right)$$

The check function $\rho_\tau(u) = u(\tau - \mathbb{I}(u < 0))$ naturally incorporates quantile-specific loss.

### Survey Weights Integration

Survey weights $w_i$ are naturally incorporated in the Bayesian framework through the weighted likelihood:

$$L(\boldsymbol{\beta}, \sigma) = \prod_{i=1}^n f(y_i|\mu_i, \sigma, \tau)^{w_i}$$

This approach maintains design consistency while providing full posterior inference.

### EM Algorithm for Multiple Quantiles

The package implements an EM algorithm that:

1. **E-step**: Computes posterior expectations of latent variables
2. **M-step**: Updates parameters via weighted optimization

Both MCMC and EM algorithms ensures:
- Computational efficiency
- Numerical stability  

## Simulation and Validation

```{r simulation}
# Built-in simulation function
sim_data <- simulate_mo_bqr_data(n = 700,
                                 beta = c(1, 2, -0.5),
                                 seed = 456)

# Fit model to simulated data
sim_model <- mo.bqr.svy(y ~ x1 + x2,
                        data = sim_data$data,
                        weights = sim_data$weights,
                        quantile = c(0.25, 0.5, 0.75),
                        verbose = FALSE)

# Compare true vs estimated coefficients
true_coefs <- c(1, 2, -0.5)
estimated_coefs <- sim_model$fit$q0.5

print("True coefficients:")
print(true_coefs)
print("Estimated coefficients quantile 0.5:")
print(estimated_coefs) 
```

## Additional Documentation

For comprehensive documentation, examples, and advanced tutorials, visit:

**ðŸ“– [https://torodriguezt.github.io/tauBayesW/](https://torodriguezt.github.io/tauBayesW/)**

## Dependencies

tauBayesW is designed to be lightweight with minimal dependencies:

- **Base R packages**: stats, grDevices, graphics
- **C++ integration**: Rcpp, RcppEigen, RcppArmadillo
- **Suggested**: survey (for complex survey examples)
- **plotly**: for interactive 3d graphics

This makes tauBayesW safe to use as a dependency in other packages without dependency conflicts.

## Package Functions Overview

| Function | Purpose | Type |
|----------|---------|------|
| `bqr.svy()` | Single quantile regression | Main |
| `mo.bqr.svy()` | Multiple quantile regression | Main |
| `plot_quantile()` | Quantile curve visualization | Plotting |
| `plot_quantile_with_points()` | Scatter plot with quantile overlay | Plotting |
| `convergence_check()` | MCMC convergence diagnostics | Diagnostic |
| `simulate_mo_bqr_data()` | Data simulation for testing | Utility |


## References
- Nascimento, M. L., & GonÃ§alves, K. C. M. (2024). Bayesian Quantile Regression Models for Complex Survey Data Under Informative Sampling. Journal of Survey Statistics and Methodology, 12(4), 1105â€“1130. https://doi.org/10.1093/jssam/smae015

- Yu, K. and Moyeed, R. A. (2001). Bayesian quantile regression. Statistics & Probability Letters, 54(4), 437-447.
---
