% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bqr.svy.R
\name{bqr.svy}
\alias{bqr.svy}
\title{Bayesian Weighted Quantile Regression (Survey Design)}
\usage{
bqr.svy(
  formula,
  weights = NULL,
  data = NULL,
  quantile = 0.5,
  method = c("ald", "score", "approximate"),
  prior = NULL,
  niter = 50000,
  burnin = 10000,
  thin = 1,
  ...
)
}
\arguments{
\item{formula}{A \code{\link{formula}} specifying the model.}

\item{weights}{Optional survey weights (numeric vector or one-sided formula).
Weights are passed directly to the underlying C++ algorithms without any
preprocessing like scaling.}

\item{data}{Optional \code{data.frame} containing the variables used in the model.}

\item{quantile}{Numeric scalar or vector in (0, 1): target quantile(s) \eqn{\tau}.
Duplicates are automatically removed.}

\item{method}{One of \code{"ald"}, \code{"score"}, \code{"approximate"}.}

\item{prior}{Prior specification. Can be:
\itemize{
\item A \code{bqr_prior} object from \code{\link{prior_default}}
\item A list with components \code{b0}, \code{B0}, and optionally \code{c0}, \code{C0}
\item \code{NULL} (uses default vague priors)
}
For \code{"ald"}: uses \code{b0}, \code{B0}, \code{c0}, \code{C0}.
For \code{"score"} and \code{"approximate"}: uses \code{b0}, \code{B0} only.}

\item{niter}{Integer. Number of MCMC iterations.}

\item{burnin}{Integer. Number of burn-in iterations.}

\item{thin}{Integer. Thinning interval.}

\item{...}{Additional arguments passed to underlying functions (reserved for future use).}
}
\value{
An object of class \code{"bqr.svy"}, containing:
\item{beta}{Posterior mean estimates of regression coefficients.}
\item{draws}{Posterior draws from the MCMC sampler.}
\item{accept_rate}{Average acceptance rate (if available).}
\item{quantile}{The quantile(s) fitted.}
\item{prior}{Prior specification used.}
\item{formula, terms, model}{Model specification details.}
\item{runtime}{Elapsed runtime in seconds.}
}
\description{
Fits a Bayesian quantile regression model with survey weights using one of
three MCMC kernels implemented in C++:
\itemize{
\item \code{.MCMC_BWQR_AL} – Asymmetric Laplace Distribution
\item \code{.MCMC_BWQR_SL} – Score likelihood
\item \code{.MCMC_BWQR_AP} – Approximate likelihood
}
One or more quantiles can be estimated, depending on the input.
}
\details{
Survey weights are handled differently by each method:
\itemize{
\item \code{"ald"} and \code{"score"}: weights are normalized (divided by their mean).
\item \code{"approximate"}: weights are used as provided (raw weights).
}

\strong{Prior Specification:}

The prior can be specified in several ways:
\enumerate{
\item Using \code{\link{prior_default}} (recommended).
\item As a list with \code{b0}, \code{B0}, and optionally \code{c0}, \code{C0}.
\item As \code{NULL}, in which case vague priors are used.
}

Multiple quantiles can be fitted in a single call. The returned object
adapts its class accordingly (\code{"bwqr_fit"} for one quantile,
\code{"bwqr_fit_multi"} for several).
}
\examples{
# Simulate data
sim <- simulate_bqr_data(n = 100, betas = c(2, 1.5, -0.8))

# Basic usage with default priors
fit1 <- bqr.svy(y ~ x1 + x2, data = sim$data, weights = sim$weights)

# With informative priors
prior <- prior_default(
  p  = 3,
  b0 = c(2, 1.5, -0.8),
  B0 = diag(c(0.25, 0.25, 0.25)),
  c0 = 3, C0 = 2
)
fit2 <- bqr.svy(y ~ x1 + x2, data = sim$data, weights = sim$weights,
                method = "ald", prior = prior)

# Compare methods
fit_score <- bqr.svy(y ~ x1 + x2, data = sim$data, weights = sim$weights,
                     method = "score")
fit_approx <- bqr.svy(y ~ x1 + x2, data = sim$data, weights = sim$weights,
                      method = "approximate")

}
