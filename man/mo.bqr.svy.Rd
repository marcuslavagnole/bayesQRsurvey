% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mo.bqr.svy.R
\name{mo.bqr.svy}
\alias{mo.bqr.svy}
\title{Multiple-Output Bayesian Quantile Regression for Complex Surveys (EM)}
\usage{
mo.bqr.svy(
  formula,
  weights = NULL,
  data,
  quantile = 0.5,
  algorithm = "em",
  prior = NULL,
  n_dir = 1,
  epsilon = 1e-06,
  max_iter = 1000,
  verbose = FALSE,
  em_mode = c("joint", "separable"),
  gamma_prior_var = 1e+06,
  ...
)
}
\arguments{
\item{formula}{A formula object specifying the model.}

\item{weights}{Optional vector of sampling weights. If \code{NULL}, equal weights are used.}

\item{data}{A data frame containing the variables in the model.}

\item{quantile}{Numeric vector of quantile levels (between 0 and 1, exclusive).}

\item{algorithm}{Character string specifying the algorithm. Currently only \code{"em"} is supported.}

\item{prior}{Prior specification. Can be:
\itemize{
\item \code{NULL}: Default priors are used for all quantiles
\item A single \code{mo_bqr_prior} object: Recycled for all quantiles
\item A list of \code{mo_bqr_prior} objects: One prior per quantile
\item A function \code{f(tau, p, names)}: Generates quantile-specific priors
}}

\item{n_dir}{Number of projection directions (if directions \code{U} are not supplied).}

\item{epsilon}{Convergence tolerance for the EM algorithm.}

\item{max_iter}{Maximum number of EM iterations.}

\item{verbose}{Logical indicating whether to print progress messages.}

\item{em_mode}{Character string, either \code{"joint"} or \code{"separable"}.
Controls whether all directions share the same orthogonal basis ("joint") or
each direction has its own basis ("separable").}

\item{gamma_prior_var}{Numeric. Prior variance for the gamma coefficients
when using \code{em_mode = "separable"}.}

\item{...}{Additional arguments for direction specification:
\describe{
\item{U}{Optional user-specified matrix of directions (\eqn{d \times K}).}
\item{Gamma}{Optional user-specified matrix of orthogonal complements
(\eqn{d \times K r}).}
\item{r}{Optional integer. Number of orthogonal complement vectors per
direction (between 0 and \eqn{d-1}). Defaults to 1 if not specified.}
}}
}
\value{
An object of class \code{"mo.bqr.svy"} containing:
\item{call}{The matched call}
\item{formula}{The model formula}
\item{terms}{The terms object}
\item{quantile}{Vector of fitted quantiles}
\item{algorithm}{Algorithm used}
\item{prior}{List of priors used for each quantile}
\item{fit}{List of fitted results for each quantile}
\item{coefficients}{Coefficients from the first quantile}
\item{n_dir}{Number of directions}
\item{U}{Matrix of projection directions}
\item{Gamma}{Matrix of orthogonal complements (if applicable)}
\item{mode}{Fitting mode, \code{"joint"} or \code{"separable"}}
}
\description{
Fits Bayesian quantile regression models for multiple quantiles simultaneously
using the EM algorithm. Supports complex survey designs through sampling weights
and allows for quantile-specific prior distributions. Can handle multiple
projection directions in either "joint" or "separable" mode.
}
\details{
This function allows for flexible prior specification across quantiles. When a list
of priors is provided, elements can be named using either \code{"q0.1"} format or
\code{"0.1"} format to match specific quantiles. When a function is provided, it
will be called with \code{(tau, p, names)} for each quantile level.

The projection directions \code{U} and their orthogonal complements \code{Gamma}
can be supplied directly, or generated automatically when only \code{n_dir} (and
optionally \code{r}) are specified.
}
\examples{
# Basic usage with default priors
fit1 <- mo.bqr.svy(y ~ x1 + x2, data = mydata,
                   quantile = c(0.1, 0.5, 0.9))

# Using quantile-specific priors via function
prior_fn <- function(tau, p, names) {
  variance <- ifelse(tau < 0.2 | tau > 0.8, 0.1, 1.0)
  mo_prior_default(p = p, beta_cov = diag(variance, p), names = names)
}
fit2 <- mo.bqr.svy(y ~ x1 + x2, data = mydata,
                   quantile = c(0.1, 0.5, 0.9), prior = prior_fn)

# Explicit control of directions
set.seed(1)
U <- matrix(rnorm(6), nrow = 3)  # d=3, K=2
fit3 <- mo.bqr.svy(y ~ x1 + x2, data = mydata,
                   quantile = 0.5, U = U, r = 2, em_mode = "separable")

}
