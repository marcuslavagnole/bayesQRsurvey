% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mo.bqr.svy.R
\name{mo.bqr.svy}
\alias{mo.bqr.svy}
\title{Multiple-Output Bayesian Quantile Regression for Complex Surveys (Directional EM)}
\usage{
mo.bqr.svy(
  formula,
  weights = NULL,
  data,
  quantile = 0.5,
  algorithm = "em",
  prior = NULL,
  n_dir = 1,
  epsilon = 1e-06,
  max_iter = 1000,
  verbose = FALSE,
  gamma_prior_var = 1e+06,
  ...
)
}
\arguments{
\item{formula}{A formula object specifying the model.}

\item{weights}{Optional vector of sampling weights. If \code{NULL}, equal weights are used.}

\item{data}{A data frame containing the variables in the model.}

\item{quantile}{Numeric vector of quantile levels (between 0 and 1, exclusive).}

\item{algorithm}{Character string specifying the algorithm. Currently only \code{"em"} is supported.}

\item{prior}{Prior specification. Can be:
\itemize{
\item \code{NULL}: Default priors are used for all quantiles
\item A single \code{mo_bqr_prior} object: Recycled for all quantiles
\item A list of \code{mo_bqr_prior} objects: One prior per quantile
\item A function \code{f(tau, p, names)}: Generates quantile-specific priors
}}

\item{n_dir}{Integer. Number of projection directions (if directions \code{U} are not supplied).}

\item{epsilon}{Convergence tolerance for the EM algorithm.}

\item{max_iter}{Maximum number of EM iterations.}

\item{verbose}{Logical indicating whether to print progress messages.}

\item{gamma_prior_var}{Numeric. Prior variance for the gamma coefficients
associated with orthogonal complements.}

\item{...}{Additional arguments for direction specification:
\describe{
\item{U}{Optional user-specified matrix of directions (\eqn{d \times K}). If not provided,
\code{n_dir} random unit vectors are generated automatically.}
}}
}
\value{
An object of class \code{"mo.bqr.svy"} containing:
\item{call}{The matched call}
\item{formula}{The model formula}
\item{terms}{The terms object}
\item{quantile}{Vector of fitted quantiles}
\item{algorithm}{Algorithm used}
\item{prior}{List of priors used for each quantile}
\item{fit}{List of fitted results for each quantile, each containing one sub-list per direction}
\item{coefficients}{Coefficients from the first quantile}
\item{n_dir}{Number of directions}
\item{U}{Matrix of projection directions (\eqn{d \times K})}
\item{Gamma_list}{List of orthogonal complement bases, one per direction}
\item{n_obs}{Number of observations}
\item{n_vars}{Number of covariates}
\item{response_dim}{Dimension of the response \eqn{d}}
}
\description{
Fits Bayesian quantile regression models for multivariate responses using the
EM algorithm and a directional approach. The method projects the response into
random unit vectors (directions) and their orthogonal complements, and then fits
univariate Bayesian quantile regression models along each projection. The
collection of fitted directions defines the multivariate quantile region.
}
\details{
The algorithm works by drawing or receiving as input a set of unit directions
\eqn{u_k \in \mathbb{R}^d}. For each direction, an orthonormal basis of its
orthogonal complement \eqn{\Gamma_k} is computed using \code{pracma::nullspace}.
The response \eqn{Y} is then projected into the pair \eqn{(u_k, \Gamma_k)}, and
a Bayesian quantile regression is fitted along that direction using the EM
algorithm. Results across all directions can be combined to approximate the
multivariate quantile region.

Prior distributions can be specified globally or quantile-specific. When a list
of priors is provided, elements can be named using either \code{"q0.1"} format or
\code{"0.1"} format to match specific quantiles. When a function is provided, it
will be called with \code{(tau, p, names)} for each quantile level.
}
\examples{
# Basic usage with default priors
fit1 <- mo.bqr.svy(y ~ x1 + x2, data = mydata,
                   quantile = c(0.1, 0.5, 0.9))

# Using quantile-specific priors via function
prior_fn <- function(tau, p, names) {
  variance <- ifelse(tau < 0.2 | tau > 0.8, 0.1, 1.0)
  mo_prior_default(p = p, beta_cov = diag(variance, p), names = names)
}
fit2 <- mo.bqr.svy(y ~ x1 + x2, data = mydata,
                   quantile = c(0.1, 0.5, 0.9), prior = prior_fn)

# Explicit control of directions
set.seed(1)
U <- matrix(rnorm(6), nrow = 3)  # d=3, K=2
U <- apply(U, 2, function(v) v / sqrt(sum(v^2))) # normalize
fit3 <- mo.bqr.svy(y ~ x1 + x2, data = mydata,
                   quantile = 0.5, U = U)

}
