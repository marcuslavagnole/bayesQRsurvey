% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_quantile.R
\name{plot_quantile_body3d.mo.bqr.svy}
\alias{plot_quantile_body3d.mo.bqr.svy}
\title{3D quantile body for \code{mo.bqr.svy} (d = 3)}
\usage{
plot_quantile_body3d.mo.bqr.svy(
  object,
  tau = NULL,
  data = NULL,
  fixed_values = NULL,
  dirs = NULL,
  engine = c("plotly", "rgl"),
  col = "#D1495B",
  opacity = 0.55,
  show_points = TRUE,
  z_by_dir = NULL
)
}
\arguments{
\item{object}{A fitted object of class \code{mo.bqr.svy} with \code{nrow(object$U) == 3}.}

\item{tau}{Numeric scalar. Quantile level to display. Defaults to the first
element in \code{object$quantile}.}

\item{data}{Optional \code{data.frame} from which sensible defaults for
\code{fixed_values} (medians/modes) are derived to build \eqn{X_0}.}

\item{fixed_values}{Optional named \code{list} giving values for covariates
(matching the model formula) to build \eqn{X_0}. Overrides values inferred
from \code{data}. Example: \code{list(x1 = 0, x2 = 1)}.}

\item{dirs}{Optional integer vector with a subset of directions \eqn{k} to plot.
By default all directions are used.}

\item{engine}{Character, \code{"plotly"} (default) for interactive plot or
\code{"rgl"} for an OpenGL window.}

\item{col}{Color for the mesh (single color). Default \code{"#D1495B"}.}

\item{opacity}{Mesh opacity in \code{[0,1]}. Default \code{0.55}.}

\item{show_points}{Logical; if \code{TRUE}, also plots the vertex cloud.}

\item{z_by_dir}{Optional list or matrix with direction-specific “gamma inputs”
when using \code{em_mode="joint"} and your specification includes directional
\eqn{\gamma_{k,c}} terms. If provided, it adds \eqn{\sum_c \gamma_{k,c} z_{k,c}}
to each radius \eqn{r_k}. Leave \code{NULL} (default) if you used \code{r = 0}.}
}
\value{
A \code{plotly} object (when \code{engine="plotly"}) or \code{NULL}
(when \code{engine="rgl"}) invisibly.
}
\description{
Draws the directional quantile body in \eqn{\mathbb{R}^3} for a fitted
\code{mo.bqr.svy} model at a fixed covariate configuration \eqn{X_0}.
For each direction \eqn{U_{\cdot k}} on the unit sphere the function computes
the directional quantile \eqn{r_k = X_0^\top \hat\beta_{\tau,k}} (or a common
\eqn{\hat\beta_\tau} in \code{em_mode="joint"}) and plots the points
\eqn{r_k U_{\cdot k}}. The convex hull of those points is rendered as a mesh.
}
\details{
The function assumes a linear predictor in the X-part. In
\code{em_mode="separable"}, the X-coefficients are direction-specific and taken
from \code{fit[[qi]]$beta_dir}. In \code{em_mode="joint"}, a single X-coefficient
vector is used for all directions. If your fit used \code{r = 0} (no \eqn{\Gamma}),
you can ignore \code{z_by_dir}.

Column-name alignment is attempted between the model matrix columns and the
stored coefficients; unnamed coefficients fall back to column order.
}
\section{Dependencies}{

Requires \pkg{plotly} for interactive rendering and \pkg{geometry} for the
convex hull (\code{convhulln}). With \code{engine="rgl"}, requires \pkg{rgl}.
}

\examples{
\dontrun{
# fit3d <- mo.bqr.svy(cbind(y1,y2,y3) ~ x1 + x2, data=mydata,
#                     quantile=0.5, algorithm="em", n_dir=60, r=0)
plot_quantile_body3d.mo.bqr.svy(fit3d,
  tau = 0.5, data = mydata, fixed_values = list(x1 = 0, x2 = 0),
  engine = "plotly", opacity = 0.6, show_points = TRUE)
}

}
